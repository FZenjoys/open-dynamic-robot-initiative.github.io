\hypertarget{demo_8cpp-example}{}\section{demo.\+cpp}
This demo shows robot\+\_\+interfaces of a dummy \char`\"{}2dof\char`\"{} robot, in which a dof \char`\"{}position\char`\"{} is represented by an integer


\begin{DoxyCodeInclude}

\textcolor{preprocessor}{#include "robot\_interfaces/monitored\_robot\_driver.hpp"}
\textcolor{preprocessor}{#include "robot\_interfaces/robot.hpp"}
\textcolor{preprocessor}{#include "robot\_interfaces/robot\_backend.hpp"}
\textcolor{preprocessor}{#include "robot\_interfaces/robot\_driver.hpp"}
\textcolor{preprocessor}{#include "robot\_interfaces/robot\_frontend.hpp"}
\textcolor{preprocessor}{#include "\hyperlink{status_8hpp}{robot\_interfaces/status.hpp}"}

\textcolor{preprocessor}{#include <memory>}

\textcolor{comment}{// Actions to be performed by robot, will be received by Driver}
\textcolor{comment}{// An action simply encapsulate two desired position value,}
\textcolor{comment}{// one for each dof}
\textcolor{keyword}{class }\hyperlink{classAction}{Action}
\{
\textcolor{keyword}{public}:
    \textcolor{keywordtype}{int} values[2];

    \textcolor{keywordtype}{void} print(\textcolor{keywordtype}{bool} backline)
    \{
        std::cout << \textcolor{stringliteral}{"action: "} << values[0] << \textcolor{stringliteral}{" "} << values[1] << \textcolor{stringliteral}{" "};
        \textcolor{keywordflow}{if} (backline) std::cout << \textcolor{stringliteral}{"\(\backslash\)n"};
    \}
\};

\textcolor{comment}{// Read from the robot by Driver}
\textcolor{comment}{// An observation is the current position}
\textcolor{comment}{// for each dof}
\textcolor{keyword}{class }\hyperlink{classObservation}{Observation}
\{
\textcolor{keyword}{public}:
    \textcolor{keywordtype}{int} values[2];

    \textcolor{keywordtype}{void} print(\textcolor{keywordtype}{bool} backline)
    \{
        std::cout << \textcolor{stringliteral}{"observation: "} << values[0] << \textcolor{stringliteral}{" "} << values[1] << \textcolor{stringliteral}{" "};
        \textcolor{keywordflow}{if} (backline) std::cout << \textcolor{stringliteral}{"\(\backslash\)n"};
    \}
\};

\textcolor{comment}{// Send command to the robot and read observation from the robot}
\textcolor{comment}{// The dof positions simply becomes the ones set by the latest action,}
\textcolor{comment}{// capped between a min and a max value (0 and 1000)}
\textcolor{keyword}{class }\hyperlink{classDriver}{Driver} : \textcolor{keyword}{public} \hyperlink{classrobot__interfaces_1_1RobotDriver}{robot\_interfaces::RobotDriver}<Action, Observation>
\{
\textcolor{keyword}{public}:
    \hyperlink{classDriver}{Driver}(\textcolor{keywordtype}{int} min, \textcolor{keywordtype}{int} max) : min\_(min), max\_(max)
    \{
    \}

    \textcolor{comment}{// at init dof are at min value}
    \textcolor{keywordtype}{void} initialize()
    \{
        state\_[0] = min\_;
        state\_[1] = min\_;
    \}

    \textcolor{comment}{// just clip desired values}
    \textcolor{comment}{// between 0 and 1000}
    \hyperlink{classAction}{Action} apply\_action(\textcolor{keyword}{const} \hyperlink{classAction}{Action} &action\_to\_apply)
    \{
        \hyperlink{classAction}{Action} applied;
        \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < 2; i++)
        \{
            \textcolor{keywordflow}{if} (action\_to\_apply.values[i] > max\_)
            \{
                applied.values[i] = max\_;
            \}
            \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (action\_to\_apply.values[i] < min\_)
            \{
                applied.values[i] = min\_;
            \}
            \textcolor{keywordflow}{else}
            \{
                applied.values[i] = action\_to\_apply.values[i];
            \}
            \textcolor{comment}{// simulating the time if could take for a real}
            \textcolor{comment}{// robot to perform the action}
            usleep(1000);
            state\_[i] = applied.values[i];
        \}
        \textcolor{keywordflow}{return} applied;
    \}

    \hyperlink{classObservation}{Observation} get\_latest\_observation()
    \{
        \hyperlink{classObservation}{Observation} observation;
        observation.values[0] = state\_[0];
        observation.values[1] = state\_[1];
        \textcolor{keywordflow}{return} observation;
    \}

    std::string get\_error()
    \{
        \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};  \textcolor{comment}{// no error}
    \}

    \textcolor{keywordtype}{void} shutdown()
    \{
    \}

\textcolor{keyword}{private}:
    \textcolor{keywordtype}{int} state\_[2];
    \textcolor{keywordtype}{int} min\_;
    \textcolor{keywordtype}{int} max\_;
\};

\textcolor{keywordtype}{int} main()
\{
    \textcolor{keyword}{typedef} \hyperlink{classrobot__interfaces_1_1RobotBackend}{robot\_interfaces::RobotBackend<Action, Observation>}
       Backend;
    \textcolor{keyword}{typedef} \hyperlink{classrobot__interfaces_1_1SingleProcessRobotData}{robot\_interfaces::SingleProcessRobotData<Action, Observation>}
       Data;
    \textcolor{keyword}{typedef} \hyperlink{classrobot__interfaces_1_1RobotFrontend}{robot\_interfaces::RobotFrontend<Action, Observation>}
       Frontend;

    \textcolor{comment}{// max time allowed for the robot to apply an action.}
    \textcolor{keywordtype}{double} max\_action\_duration\_s = 0.02;

    \textcolor{comment}{// max time allowed for 2 successive actions}
    \textcolor{keywordtype}{double} max\_inter\_action\_duration\_s = 0.05;

    \textcolor{comment}{// demo showing the separated usage of backend and frontend}
    \{
        std::cout << \textcolor{stringliteral}{"\(\backslash\)n -- * -- Frontend and Backend -- * --\(\backslash\)n"} << std::endl;

        std::shared\_ptr<Driver> driver\_ptr = std::make\_shared<Driver>(0, 1000);
        \textcolor{comment}{// Wrap the driver in a MonitoredRobotDriver to automatically run a}
        \textcolor{comment}{// timing watchdog.  If timing is violated, the robot will immediately}
        \textcolor{comment}{// be shut down.}
        \textcolor{comment}{// If no time monitoring is needed in your application, you can simply}
        \textcolor{comment}{// use the `driver\_ptr` directly, without the wrapper.}
        \textcolor{keyword}{auto} monitored\_driver\_ptr = std::make\_shared<
            \hyperlink{classrobot__interfaces_1_1MonitoredRobotDriver}{robot\_interfaces::MonitoredRobotDriver<Driver>}>(
            driver\_ptr, max\_action\_duration\_s, max\_inter\_action\_duration\_s);

        std::shared\_ptr<Data> data\_ptr = std::make\_shared<Data>();

        Backend backend(monitored\_driver\_ptr, data\_ptr);
        backend.initialize();

        Frontend frontend(data\_ptr);

        \hyperlink{classAction}{Action} action;
        \hyperlink{classObservation}{Observation} observation;

        \textcolor{comment}{// simulated action :}
        \textcolor{comment}{// 1 dof going from 200 to 300}
        \textcolor{comment}{// The other going from 300 to 200}

        \textcolor{keywordflow}{for} (uint value = 200; value <= 300; value++)
        \{
            action.values[0] = value;
            action.values[1] = 500 - value;
            \textcolor{comment}{// this action will be stored at index}
            robot\_interfaces::TimeIndex index =
                frontend.append\_desired\_action(action);
            \textcolor{comment}{// getting the observation corresponding to the applied}
            \textcolor{comment}{// action, i.e. at the same index}
            observation = frontend.get\_observation(index);
            std::cout << \textcolor{stringliteral}{"value: "} << value << \textcolor{stringliteral}{" | "};
            action.print(\textcolor{keyword}{false});
            observation.print(\textcolor{keyword}{true});
        \}
    \}

    \textcolor{comment}{// demo representing usage of frontend and backend}
    \textcolor{comment}{// encapsulated in the same instance}
    \{
        std::cout << \textcolor{stringliteral}{"\(\backslash\)n -- * -- Robot -- * --\(\backslash\)n"} << std::endl;

        \textcolor{keyword}{typedef} \hyperlink{classrobot__interfaces_1_1Robot}{robot\_interfaces::Robot<Action, Observation, Driver>}
       Robot;

        \textcolor{keywordtype}{int} min = 0;
        \textcolor{keywordtype}{int} max = 100;
        Robot robot(
            max\_action\_duration\_s, max\_inter\_action\_duration\_s, min, max);

        robot.initialize();

        \hyperlink{classAction}{Action} action;
        \hyperlink{classObservation}{Observation} observation;

        \textcolor{comment}{// simulated action :}
        \textcolor{comment}{// 1 dof going from 200 to 300}
        \textcolor{comment}{// The other going from 300 to 200}

        \textcolor{keywordflow}{for} (uint value = 200; value <= 300; value++)
        \{
            action.values[0] = value;
            action.values[1] = 500 - value;
            \textcolor{comment}{// this action will be stored at index}
            robot\_interfaces::TimeIndex index =
                robot.append\_desired\_action(action);
            \textcolor{comment}{// getting the observation corresponding to the applied}
            \textcolor{comment}{// action, i.e. at the same index}
            observation = robot.get\_observation(index);
            std::cout << \textcolor{stringliteral}{"value: "} << value << \textcolor{stringliteral}{" | "};
            action.print(\textcolor{keyword}{false});
            observation.print(\textcolor{keyword}{true});
        \}
    \}
\}
\end{DoxyCodeInclude}
 